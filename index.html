<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anatomy Pro - iOS Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            color: white; background: rgba(0,0,0,0.85); padding: 15px; 
            border-radius: 12px; border-left: 4px solid #00d2ff;
            max-width: 200px; backdrop-filter: blur(8px);
            pointer-events: none;
            font-size: 0.8rem; /* Pi√π piccolo per mobile */
        }
        h2 { margin: 0 0 5px 0; font-size: 1rem; text-transform: uppercase; color: #00d2ff; }
        
        .status-row { display: flex; align-items: center; margin-bottom: 5px; color: #aaa; }
        .active { color: #fff; font-weight: bold; }

        #current-state {
            margin-top: 10px; padding: 5px; background: #222; border-radius: 4px;
            text-align: center; font-weight: bold; border: 1px solid #444;
        }
        .st-idle { color: #888; }
        .st-explode { color: #00d2ff; }
        .st-grab { color: #ff0055; }

        #selected-part { color: #ffff00; font-weight: bold; margin-top: 5px; text-align: center; }

        /* Console Errori Visiva per Mobile */
        #debug-console {
            position: absolute; bottom: 0; left: 0; width: 100%; max-height: 100px;
            background: rgba(50,0,0,0.8); color: #ffaaaa; font-family: monospace;
            font-size: 10px; overflow-y: scroll; z-index: 999; pointer-events: none;
            display: none; /* Appare solo se ci sono errori */
        }

        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 5;
            width: 120px; height: 160px; border-radius: 12px; overflow: hidden;
            border: 2px solid #333; transform: scaleX(-1); opacity: 0.5;
        }
        /* FIX IMPORTANTE PER IOS: Video deve riempire il container */
        video { width: 100%; height: 100%; object-fit: cover; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00d2ff; font-size: 1.2rem; font-weight: bold;
            background: #111; padding: 30px; border: 1px solid #00d2ff; border-radius: 50%;
            width: 150px; height: 150px; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 50px rgba(0, 210, 255, 0.2); z-index: 100; text-align: center;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">Avvio<br>Camera...</div>
    <div id="debug-console"></div>

    <div id="ui">
        <h2>Mobile Controller</h2>
        <div class="status-row" id="row-idle">‚úä Unisci</div>
        <div class="status-row" id="row-explode">üñêÔ∏è Esplodi</div>
        <div class="status-row" id="row-grab">üëå Zoom/Pinch</div>
        
        <div id="current-state" class="st-idle">ATTESA</div>
        <div id="selected-part">...</div>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // --- SISTEMA DI LOGGING PER MOBILE ---
        function logError(msg) {
            const consoleDiv = document.getElementById('debug-console');
            consoleDiv.style.display = 'block';
            consoleDiv.innerHTML += `<div>> ${msg}</div>`;
            console.error(msg);
        }
        window.onerror = function(message, source, lineno, colno, error) {
            logError(message);
        };

        // --- 1. SETUP AMBIENTE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 300);
        camera.position.set(0, 0, 14); // Leggermente pi√π lontano per schermi piccoli

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Luci
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const mainLight = new THREE.DirectionalLight(0xffffff, 2);
        mainLight.position.set(5, 5, 5);
        scene.add(mainLight);

        const pivotGroup = new THREE.Group();
        scene.add(pivotGroup);

        const cursorMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, depthTest: false })
        );
        cursorMesh.renderOrder = 999; 
        scene.add(cursorMesh);

        // --- 2. LOGICA ---
        let partsData = [];
        const STATE = { IDLE: 'idle', EXPLODE: 'explode', GRAB: 'grab' };
        let currentState = STATE.IDLE;
        
        let grabbedObject = null;
        let hoveredObject = null;
        let pinchStartDistance = 0;
        let explosionFactor = 0;
        let targetExplosion = 0;

        let targetHand = { x: 0, y: 0, z: 0 }; 
        let smoothHand = { x: 0, y: 0, z: 0 }; 
        const SMOOTHING_FACTOR = 0.15; 

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // UI Refs
        const uiState = document.getElementById('current-state');
        const uiPart = document.getElementById('selected-part');
        const loaderUi = document.getElementById('loader');

        // --- 3. CARICAMENTO ---
        const loader = new GLTFLoader();
        const draco = new DRACOLoader();
        draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(draco);

        loader.load('./modello.glb', (gltf) => {
            const model = gltf.scene;
            loaderUi.innerText = "Caricamento AI...";

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            model.position.sub(center);
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 4.0 / maxDim; 
            pivotGroup.scale.set(scale, scale, scale);
            pivotGroup.add(model);

            let index = 0;
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true; 
                    child.material.opacity = 1.0;
                    
                    if (!child.name) child.name = "Parte_" + index++;

                    child.geometry.computeBoundingSphere();
                    const meshCenter = child.geometry.boundingSphere.center.clone();
                    meshCenter.applyMatrix4(child.matrix); 

                    let explodeDir = meshCenter.clone().normalize();
                    explodeDir.normalize().multiplyScalar(105.0); 

                    partsData.push({
                        mesh: child,
                        originalPos: child.position.clone(),
                        originalRot: child.quaternion.clone(),
                        explodeVector: explodeDir
                    });
                }
            });
            loaderUi.style.display = 'none'; // Nascondi loader solo a fine caricamento 3D

        }, undefined, (err) => logError("Errore GLB: " + err.message));


        // --- 4. GESTIONE MATERIALI ---
        function updateMaterials() {
            partsData.forEach(part => {
                const mesh = part.mesh;
                const mat = mesh.material;
                const isGrabbed = (grabbedObject === mesh);
                const isHovered = (hoveredObject === mesh);

                if (currentState === STATE.GRAB && grabbedObject) {
                    if (isGrabbed) {
                        mat.opacity = 1.0; mat.visible = true; mat.emissive.setHex(0x550000); 
                    } else {
                        mat.opacity = 0.0; mat.visible = false; 
                    }
                } else if (currentState === STATE.EXPLODE) {
                    mat.visible = true;
                    if (isHovered) {
                        mat.opacity = 1.0; mat.emissive.setHex(0x333333); 
                    } else {
                        mat.opacity = 0.2; mat.emissive.setHex(0x000000);
                    }
                } else {
                    mat.visible = true; mat.opacity = 1.0; mat.emissive.setHex(0x000000);
                }
            });
        }

        // --- 5. MEDIAPIPE & GESTI ---
        function onResults(results) {
            // Se non ci sono mani, esci
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if (currentState !== STATE.IDLE) changeState(STATE.IDLE);
                cursorMesh.visible = false;
                return;
            }
            cursorMesh.visible = true;

            const landmarks = results.multiHandLandmarks[0];
            const index = landmarks[8];
            const thumb = landmarks[4];
            const wrist = landmarks[0];

            // Calcolo Smooth
            const rawX = -( ((index.x + thumb.x)/2) * 2 ) + 1;
            const rawY = -( ((index.y + thumb.y)/2) * 2 ) + 1;
            const rawZ = wrist.z; 

            smoothHand.x += (rawX - smoothHand.x) * SMOOTHING_FACTOR;
            smoothHand.y += (rawY - smoothHand.y) * SMOOTHING_FACTOR;
            smoothHand.z += (rawZ - smoothHand.z) * SMOOTHING_FACTOR;

            const handX = smoothHand.x;
            const handY = smoothHand.y;
            const handZ = smoothHand.z;

            // Cursore
            const vec = new THREE.Vector3(handX, handY, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            cursorMesh.position.copy(camera.position.clone().add(dir.multiplyScalar(distance)));

            // Logica Gesti
            const pinchDist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
            const PINCH_START = 0.05; // Soglia leggermente aumentata per mobile
            const PINCH_RELEASE = 0.12; 

            let isPinching = (currentState === STATE.GRAB);
            if (!isPinching && pinchDist < PINCH_START) isPinching = true;
            else if (isPinching && pinchDist > PINCH_RELEASE) isPinching = false;

            let openFingers = 0;
            [8, 12, 16, 20].forEach(tip => { if (landmarks[tip].y < landmarks[tip-2].y) openFingers++; });

            if (isPinching) {
                changeState(STATE.GRAB);
                if (!grabbedObject && hoveredObject) {
                    grabbedObject = hoveredObject;
                    pinchStartDistance = handZ;
                    uiPart.innerText = grabbedObject.name;
                    updateMaterials();
                }
                if (grabbedObject) {
                    grabbedObject.rotation.y += (handX - targetHand.prevX || 0) * 8; 
                    grabbedObject.rotation.x += (handY - targetHand.prevY || 0) * 8;
                    const zoomDelta = (handZ - pinchStartDistance) * 25;
                    let scale = 1 + zoomDelta;
                    scale = Math.max(0.5, Math.min(6.0, scale)); 
                    grabbedObject.scale.setScalar(scale);
                    
                    // Zoom fisico Z
                    const moveZ = (handZ - pinchStartDistance) * 20;
                    grabbedObject.position.z = Math.max(-10, Math.min(8, moveZ));
                }

            } else if (openFingers >= 3) {
                if (grabbedObject) releaseObject();
                changeState(STATE.EXPLODE);
                pivotGroup.rotation.y -= (handX - (targetHand.prevX || 0)) * 2;
                pivotGroup.rotation.x -= (handY - (targetHand.prevY || 0)) * 2;
                
            } else {
                if (grabbedObject) releaseObject();
                changeState(STATE.IDLE);
                pivotGroup.rotation.y -= (handX - (targetHand.prevX || 0)) * 2;
                pivotGroup.rotation.x -= (handY - (targetHand.prevY || 0)) * 2;
            }

            if (!grabbedObject) {
                mouse.x = handX;
                mouse.y = handY;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(pivotGroup.children, true);
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (hoveredObject !== obj) {
                        hoveredObject = obj;
                        uiPart.innerText = obj.name;
                        if (currentState === STATE.EXPLODE) updateMaterials();
                    }
                } else {
                    if (hoveredObject) {
                        hoveredObject = null;
                        uiPart.innerText = "...";
                        if (currentState === STATE.EXPLODE) updateMaterials();
                    }
                }
            }
            targetHand.prevX = handX;
            targetHand.prevY = handY;
        }

        function releaseObject() {
            if (grabbedObject) {
                grabbedObject = null;
                updateMaterials();
            }
        }

        function changeState(newState) {
            if (currentState === newState) return;
            currentState = newState;

            uiState.className = '';
            document.querySelectorAll('.status-row').forEach(el => el.classList.remove('active'));

            if (newState === STATE.IDLE) {
                targetExplosion = 0;
                uiState.innerText = "RICOMPOSIZIONE";
                uiState.classList.add('st-idle');
                document.getElementById('row-idle').classList.add('active');
            } else if (newState === STATE.EXPLODE) {
                targetExplosion = 1;
                uiState.innerText = "ESPLOSIONE";
                uiState.classList.add('st-explode');
                document.getElementById('row-explode').classList.add('active');
            } else if (newState === STATE.GRAB) {
                uiState.innerText = "ISOLAMENTO";
                uiState.classList.add('st-grab');
                document.getElementById('row-grab').classList.add('active');
            }
            updateMaterials();
        }

        // --- 6. ANIMAZIONE ---
        function animate() {
            requestAnimationFrame(animate);
            explosionFactor += (targetExplosion - explosionFactor) * 0.1;

            if (partsData.length > 0) {
                partsData.forEach(part => {
                    if (grabbedObject === part.mesh) return;
                    let targetPos = (currentState === STATE.EXPLODE) ? 
                        part.originalPos.clone().add(part.explodeVector.clone().multiplyScalar(explosionFactor)) : 
                        part.originalPos;

                    part.mesh.position.lerp(targetPos, 0.1);
                    part.mesh.quaternion.slerp(part.originalRot, 0.1);
                    part.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    // Reset Z fisico
                    if(part.mesh.position.z !== targetPos.z && currentState !== STATE.GRAB) {
                         part.mesh.position.z += (targetPos.z - part.mesh.position.z) * 0.1;
                    }
                });
            }
            renderer.render(scene, camera);
        }
        animate();

        // --- SETUP CAMERA MEDIAPIPE (IOS FRIENDLY) ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const videoElem = document.getElementById('input-video');
        
        // Configurazione specifica per compatibilit√† mobile
        const cameraUtils = new Camera(videoElem, {
            onFrame: async () => { await hands.send({image: videoElem}); },
            width: 1280, // Richiedi HD, spesso aiuta iOS a scegliere la camera giusta
            height: 720,
            facingMode: 'user' // FONDAMENTALE: Richiede camera frontale
        });
        
        // Avvio protetto
        cameraUtils.start().catch(err => {
            logError("Errore Camera: " + err);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
